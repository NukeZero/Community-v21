*9/8b 
.추가로 로딩하겠습니까? 에서 NO를 선택하면 기존 모델과 겹쳐보이던 버그를 수정.

*9/8a
.o3d를 로딩하고 다시 o3d를 로딩하려 하면 기존모델과 함께 추가로딩이 가능하게 되었습니다.

*9/8
.o3d를 읽을때 사용하는 텍스쳐를, 옵션에서 지정된 텍스쳐폴더에서 먼저 찾은 후 없으면 에러가 났는데
 o3d가 있는 폴더에 텍스쳐를 우선적으로 찾고, 없다면 옵션에서 지정된 텍스쳐폴더에서 찾도록 수정했습니다.
.버텍스와 피지크 개수가 맞지 않다 라는 에러메시지에 어떤 오브젝트가 그런지를 표시했습니다. 그리고 버텍스 개수와 피지크 개수도 같이 표시했습니다.





* LOD계획
- 각 LOD를 Group으로 묶어 #lod1, #lod2, #lod3으로 이름 붙임.	1 = High  2 = Medium   3 = Low 입니다..
- 파츠lod를 만들땐 lod1의 파츠이름과 lod2의 파츠이름이 같게 할것. Merge로 읽어들이면 같게 된다.
- 2단계는 50%  3단계는 25%정도.
- 가장 먼 3단계는 가급적이면 단일오브젝트에 애니메이션 없게 한다. 인간일경우 육면체 박스로만 구성할것.


* 캐릭터 툴이 갖춰야 할 요소
- 맥스에서 채 넣지 못한 애니메이션 정보를 삽입할 수 있어야 한다.
- 캐릭터, 아이템, 배경오브젝트 등의 속성을 편집할 수 있어야 한다.

1. 편집
* 애니메이션 프레임단위 편집
. 사운드 연결하기
. 데미지정보, 영역 삽입하기
. Draw방법에 대한 정보
. 애니메이션 스피드 조절에 관한 정보

* 파라메터
. 무기 오브젝트의 검광시작/끝부분 버텍스 번호 설정
 - 버텍스 단위로 선택하여 시작과 끝을 지정 한다

* 오브젝트단위 속성
. 바운딩박스 지정
. 

2. 뷰어
. 게임모델 파일을 열어서 확인하고 애니메이션 시켜볼 수 있어야 한다.
. 파트조합 인간형 모델일경우는 직접 여러가지 의상/무기을 입혀볼 수 있어야 한다.

3. 컨버터
. ASE -> bon, ani, mes로 변환을 배치파일로 일괄 변환할수 있도록.


* 본과 메쉬를 읽음.
* 무기를 읽어 손에 장착.
* 

< 텍스쳐 UV스크롤 정보 편집 >
* 스크롤 방향과 속도
* U스크롤값, V스크롤값 방향과 속도를 한번에 편집.
* 

* 환경매핑
* Cola에서 환경매핑 지원

* Cola
 # 공격동작의 타격지점 설정
 # 모션중 사운드 출력 지점 설정
 . 효율적인 ase -> o3d 컨버팅 방식(검광 지점 지정등...)
 . 부분 opacity, reflect지원
 . 기타 인터페이스 개선.

* Max
 . 맥스의 이동좌표를 그대로 사용할 수 있게(예:죽는모션)
 # 2 side 폴리곤 지정. - o3d 다시 컨버트 하고 __X2SIDE로 컴팔
 . 버텍스 애니메이션 지원

* Engine
 . 2link 스키닝 지원
 . 스키닝 버텍스 쉐이더버전.
 . 뷰 프러스텀 컬링 최적화
 . 효율적인 폴리곤관리(octree같은..)
 . 그림자 처리
 . 물리적 옷감 시뮬레이션


#2/28
* 버텍스쉐이더 스키닝 계획
 # 기존ASE파일의 더미/손가락/발가락/footstep 뼈대는 무시하도록 해서 뼈대개수를 줄인다. mvr_heroine을 이용하자.
 # 일단은 0 weight로 해서 쉐이더 간단하게 만들어 보자.  기존데이타도 그대로 이용하고. 텍스쳐는 한장짜리
 . 쉐이더로 동작하는것을 확인후, 텍스쳐 2개이상짜리를 사용하도록 뼈대인덱스 데이타 정렬
 . 텍스쳐가 하나라도 뼈대가 많은경우 반으로 나눠서 쉐이더로 할수 있게 정렬
 . 2-link 스키닝 쉐이더.


#3/06
* 계획
// . bon파일을 다시 사용하자. 그래서 m_mUpdateBone이 없어도 기본bon으로 o3d를 표현할수있게 하자
 . 위 계획 취소됨.

#3/7
if( 모델(ASE)단위로 본이 28개 이상인가? )
{
	if( GEOMOBJECT단위로 검사해서 본을 28개 이상 쓰는가? )
		if( 매터리얼블럭 단위로 검사해서 본을 28개 이상 쓰는가? )
			28개 단위로 블럭을 쪼개자;

		매터리얼 블럭 전송하기전에 본을 VS로 전송하는 방식으로 설정
	else
		GeoMObject렌더링 하기전에, 사용하는 본의 리스트를 VS로 전송하는 방식으로 설정
} else
	모델렌더링 하기전에 본의 리스트를 VS로 전송(기존방식)하는 방식으로 설정
. 
매터리얼 블럭내에서 사용되는 본의 개수가 28개를 초과하면 '특별찍기모드'가 되어 
  본을 28개씩으로 쪼개어 버텍스의 참조뼈대인덱스를 재설정하고 찍기전엔 그 본을 전송하는 과정을
  추가한다.  '특별찍기모드'는 전용 Render()를 만들어서 함수포인터로 호출하는게 좋겠다.
  
  
. m_pVB는 스태틱이나 스킨이나 관계없이 같은 포맷으로 쓸수 있게 하고
스킨오브젝만 m_pVB이용을 위해서 

#3/19
//		pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
//		pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
//		pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

//		pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
//		pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
//		pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
//		pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
//		pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );

//		pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_ARGB( m_dwBlendFactor, 0, 0, 0) );

* max파일의 특정목적을 위한 오브젝트
. 이벤트 위치 오브젝트 - 화살이 발생되는 위치같은.  #event1 더미로 생성
. 충돌용 메시 - #coll - 메시로 생성.
. LOD용 메시








vs.1.1
;------------------------------------------------------------------------------
; Constants specified by the app
;    c0-c83  = bone matrix index 0 ~ 28
;    c84-c87 = matViewProj
;    c88-c91 = reserved
;    c92     = light direction
;    c93     = material diffuse color * light diffuse color
;    c94     = material ambient color
;    c95     = const 1.0f, 1.0f, 1.0f, 100.0f
;	
;
; Vertex components (as specified in the vertex DECL)
;   v0    = Position
;	v1	  = w1, w2
;	v2.x  = matrix idx
;	v3    = Normal
;	v4    = Texcoords
;------------------------------------------------------------------------------

dcl_position v0;
dcl_blendweight v1;
dcl_blendindices v2;
dcl_normal v3;
dcl_texcoord0 v4;


;------------------------------------------------------------------------------
; Vertex blending
;------------------------------------------------------------------------------

; Transform position for world0 matrix
mov a0.x, v2.x				; matrix index 1
m4x3 r0, v0, c[a0.x]		; r0 = pos * (InvTM * AniTM)
;m3x3 r3, v3, c[a0.x]		;normal transform
mul  r1, r0.xyz, v1.x		; r1 = r0 * w1
;mul  r4, r3.xyz, v1.x		

mov  a0.x, v2.y				; matrix index 2
m4x3 r0, v0, c[a0.x]		; r0 = pos * (InvTM * AniTM)
;m3x3 r3, v3, c[a0.x]		;normal transform
mad  r1, r0.xyz, v1.y, r1.xyz ; w2곱하고 위에거랑 더함
;mad  r3, r3.xyz, v1.y, r4.xyz ; w2곱하고 위에거랑 더함

mov  r1.w, c95.x			; r1.w = 1.0f

;m4x4 r0, r0, c88
;m4x4 oPos, r1, c84			; oPos = 결과벡터 * matViewProj
mov r0, v0
mov r0.w, c95.x
mov oPos, r0


;------------------------------------------------------------------------------
; Lighting calculation
;------------------------------------------------------------------------------
; directional light
;dp3 r1.x, r3, -c92   ; N 와 L 의 내적
;mul r2, r1.x, c93	; n * diffuse
;add oD0, r2, c94	; + ambient

mov oD0, c95.xxxx	; no lighting

;dp3 r0.x, r3, -c92	; vLight dot normal
;sub r1, c88, v0		; vertex -> eyepos
;dp3 r1.w, r1, r1	; vertex->eyepos vector normalize
;rsq r1.w, r1.w
;mul r1, r1, r1.w

;add r2, r1, -c92
;dp3 r2.w, r2, r2
;rsq r2.w, r2.w
;mul r2, r2, r2.w

;dp3 r0.y, r2, r3

;mov r0.w, c89.w		; specular power

;lit r4, r0

;mul r5, r4.z, c89	; specular
;mul r6, r4.y, c90	; c90을 light color로 잠시 썼다. 1, 1, 1, 1
;mul r6, r6, c93
;add r6, r6, c94		; * diffuse + ambient
;add oD0, r5, r6

;------------------------------------------------------------------------------
; Texture coordinates
;------------------------------------------------------------------------------

; Just copy the texture coordinates
mov oT0.xy,  v4.xy
;mov oT1.xy,  v4.xy

mov oFog, c95.w



void	CModelObject :: SetStateShadow( LPDIRECT3DDEVICE9 pd3dDevice )
{
	pd3dDevice->Clear( 0, NULL, D3DCLEAR_STENCIL, 0, 1.0f, 0);
 
	pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, TRUE);
    pd3dDevice->SetRenderState(D3DRS_STENCILFUNC,   D3DCMP_ALWAYS);
    pd3dDevice->SetRenderState(D3DRS_STENCILPASS,   D3DSTENCILOP_INCR);
    pd3dDevice->SetRenderState(D3DRS_STENCILREF,    1);

	pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);

//	pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );
	pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
//	pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
//	pd3dDevice->SetRenderState(D3DRS_SRCBLEND,  D3DBLEND_ZERO);
//	pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

	pd3dDevice->SetRenderState(D3DRS_DEPTHBIAS, 0);
}

void	CModelObject :: ResetStateShadow( LPDIRECT3DDEVICE9 pd3dDevice )
{
    pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE );

}


//
//
//
int		CModelObject::RenderShadow( LPDIRECT3DDEVICE9 pd3dDevice, const D3DXMATRIX *mWorld, const D3DXVECTOR3 &vLightPos, const D3DXVECTOR3 &vLightDir )
{
	//	m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);

	CObject3D	*pObject3D;
	O3D_ELEMENT	*pElem;
	int		i;
	int		nNextFrame;
	D3DXMATRIX	m1;

#ifdef	__XVS
	#ifdef	_DEBUG
	if( m_mUpdateBone && g_pSkiningVS == NULL )
		Error( "CMyD3DApplication::RestoreDeviceObjects()에 CreateSkiningVS()를 호출하시오.\r\nCMyD3DApplication::InvalidateDeviceObjects()에는 DeleteSkiningVS()를 호출하시오." );
	#endif
#endif

	if( m_pMotion )		// m_pMotion이 널이라면 m_mUpdateBone도 널이다.
		m_pMotion->AnimateBone( m_mUpdateBone, m_pMotionOld, m_fFrameCurrent, GetNextFrame(), m_nFrameOld, m_bMotionBlending, m_fBlendWeight );		// 일단 뼈대가 있다면 뼈대 애니메이션 시킴

#ifdef	__XVS
	if( m_pBone )		// m_pBone이 있다면 뼈대가 있다는 얘기. VS를 써야 한다.
	{
		D3DXMATRIX *pmBones;
		D3DXMATRIX mWorldTranspose;
		D3DXMATRIX *pmBonesInv = m_pBaseBoneInv ;
		if( m_mUpdateBone )		pmBones = m_mUpdateBone;
		else					pmBones = m_pBaseBone;		// 뼈대모션이 로딩된게 없으면 디폴트를 쓴다.
		
		if( m_bSendVS )	// 뼈대개수가 MAX_VS_BONE이하라서 한번에 다 전송한다.
		{
			int		nMaxBone = m_nMaxBone;
	#ifdef	__XDEBUG
			if( nMaxBone > MAX_VS_BONE )	
				Error( "CModelObject::Render : 뼈대개수가 최대치를 초과했다. %d", nMaxBone );
	#endif
			for( i = 0; i < nMaxBone; i ++ )	// MAX_VS_BONE개 이하	
			{
#ifdef	__X2LINK
				mWorldTranspose = pmBonesInv[i] * pmBones[i];
				D3DXMatrixTranspose( &mWorldTranspose, &mWorldTranspose );		// 매트릭스를 돌린다음.
#else
				D3DXMatrixTranspose( &mWorldTranspose, &pmBones[i] );		// 매트릭스를 돌린다음.
#endif
				m_pd3dDevice->SetVertexShaderConstantF( i * 3, (float*)&mWorldTranspose, 3 );		// 상수레지스터에 집어넣음.
			}
		}

		D3DXMATRIX	mView, mProj;
		D3DXMATRIX	mViewProj, mViewProjTranspose, mInvWorld;

		m_pd3dDevice->GetTransform( D3DTS_VIEW,       &mView );
		m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &mProj );
		mViewProj = *mWorld * mView * mProj;
		D3DXMatrixTranspose( &mViewProjTranspose, &mViewProj );
//		D3DXMatrixTranspose( &mWorldTranspose, mWorld );

		m_pd3dDevice->SetVertexShaderConstantF( 84, (float*)&mViewProjTranspose, 4 );
//		m_pd3dDevice->SetVertexShaderConstantF( 88, (float*)&mWorldTranspose, 4 );
	}
#endif
	// 기본 설정 
/*	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL   );		
	pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA  );
	pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_ARGB( m_dwBlendFactor, 0, 0, 0) );
*/
	// 오브젝트의 반투명 효과 세팅 
	if( m_dwBlendFactor < 255 )
	{
		pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
		pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
	}
	/*
		pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
	*/

	nNextFrame = GetNextFrame();
	pd3dDevice->SetMaterial( g_TextureMng.GetMaterial( pd3dDevice, 0 ) );
#ifndef	__XVS
	pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
#endif

	pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
	// 앞면 렌더
	for( i = 0; i < MAX_ELEMENT; i ++ )
	{
		pElem = &m_Element[i];
		pObject3D = pElem->m_pObject3D;
		if( pObject3D == NULL )		continue;

		// 뼈대에 링크되어 있다.
		if( pElem->m_nParentIdx != -1 )		// 본의 인덱스를 뜻한다.
		{
			// 만약 본의 개수가 바뀌었다면 ParentIdx도 틀려졌기 때문에 바꿔줘야 한다.
			m1 = m_mUpdateBone[ pElem->m_nParentIdx ] * *mWorld;		// 뼈대에 링크되어 있다면 뼈대위치가 센터가 된다.
			if( pElem->m_nParentIdx == BONE_RHAND )
				m1 = pElem->m_mLocalRH * m1;
			if( pElem->m_nParentIdx == BONE_LFOREARM )
				m1 = pElem->m_mLocalShield * m1;
		}
		else
			m1 = *mWorld;
		
		if( m_mUpdateBone )
			pObject3D->SetExternBone( m_mUpdateBone );
		pObject3D->RenderShadow( pd3dDevice, m_fFrameCurrent, nNextFrame, &m1, m_dwBlendFactor, vLightPos, vLightDir );

	}

	// 뒷면 렌더
	pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CW );
    pd3dDevice->SetRenderState( D3DRS_STENCILPASS,   D3DSTENCILOP_DECR );
	for( i = 0; i < MAX_ELEMENT; i ++ )
	{
		pElem = &m_Element[i];
		pObject3D = pElem->m_pObject3D;
		if( pObject3D == NULL )		continue;
		
		// 뼈대에 링크되어 있다.
		if( pElem->m_nParentIdx != -1 )		// 본의 인덱스를 뜻한다.
		{
			// 만약 본의 개수가 바뀌었다면 ParentIdx도 틀려졌기 때문에 바꿔줘야 한다.
			m1 = m_mUpdateBone[ pElem->m_nParentIdx ] * *mWorld;		// 뼈대에 링크되어 있다면 뼈대위치가 센터가 된다.
			if( pElem->m_nParentIdx == BONE_RHAND )
				m1 = pElem->m_mLocalRH * m1;
			if( pElem->m_nParentIdx == BONE_LFOREARM )
				m1 = pElem->m_mLocalShield * m1;
		}
		else
			m1 = *mWorld;
		
		if( m_mUpdateBone )
			pObject3D->SetExternBone( m_mUpdateBone );
		pObject3D->RenderShadow( pd3dDevice, m_fFrameCurrent, nNextFrame, &m1, m_dwBlendFactor, vLightPos, vLightDir  );
		
	}
	
	
	// 상태 해제
	if( m_dwBlendFactor < 255 )
	{
		pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
		pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	}

	// 검광 렌더.
//	if( m_pForce && m_pForce->m_nMaxSpline > 0 )	m_pForce->Draw( pd3dDevice, mWorld );

	return 1;
}
#endif // SHADOW
